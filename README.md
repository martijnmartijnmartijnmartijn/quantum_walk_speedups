# quantum_walk_speedups

This repository allows you to generate several types of random SAT instances,
solve them with a basic backtracking solver and a more modern sat solver,
and plot the resulting time complexity. Most importantly, the data
gathered from the backtracking solver can be used to determine the query
complexity of a quantum walk algorithm that solves SAT instances by walking
on the classical backtracking tree (an algorithm due to Montanaro 2018,
`https://theoryofcomputing.org/articles/v014a015`), and subsequently the
T-depth and T-count of a quantum circuit implmenting these quantum queries.
These can be plotted to gain insight into to possibility of a quantum speed-up.

Overview of repository:

- `run_experiment.py` can be used to generate SAT instances of a given type,
  which are then solved, saving the relevant data to files into a .csv file
  in the `data/` folder. See the documentation in the file itself for precise
  usage instructions.
- `plot_queries_over_n.py` can be called using the .csv files output by
  `run_experiment.py` to plot the measured time complexity of the classical
  solvers, and the computed T-depth and T-count of the quantum algorithm(s).
- `library.py` contains some functions used to determine the optimal
  configuration of the quantum walk algorithm (i.e. determine C and number
  of repetitions). These functions are not used elsewhere in the code.
- `data/` contains all the .csv files generated by `run_experiment.py`.
- `gate_complexity/` contains two files from the code from
  `https://doi.org/10.22331/q-2019-07-18-167` which compute the circuit
  size/depth for circuits needed to implement Grover/quantum walk queries.
- `generators-IJCAI17` contains files from
  `https://www.ijcai.org/proceedings/2017/89` that are used to generate random
  SAT instances with community structure.
- `solvers/bt` contains used backtracking solver in `bt.c` (modified from the
  solver used in `https://doi.org/10.5523/bris.19va21gun3c7629f291kmd6w37`)
  which can be compiled using the given makefile.
- `solvers/CaDiCaL` contains version 1.9.5 of the CaDiCaL SAT solver (cloned
  from `https://github.com/arminbiere/cadical`).
- `solvers/SBVA` contains the SBVA pre-processer for SAT instances, which
  conjoined with CaDiCaL 1.9.5 was the winner of the 2023 SAT competition
  (cloned from `https://github.com/hgarrereyn/SBVA`)/

# Usage

1. Build the community SAT generator by going to `generators-IJCAI17` and
   running `make`.
1. Build the backtracking sat solver by going to `solvers/bt` and running `make`.
1. Build the CaDiCaL solver by going to `solvers/CaDiCaL` and running `./configure && make`.
1. Install the dependency Eigen for SBVA by going to `solvers/SBVA` and running

```
wget https://gitlab.com/libeigen/eigen/-/archive/3.4.0/eigen-3.4.0.tar.gz
tar xf eigen-3.4.0.tar.gz
```

5. Build SBVA by going to `solvers/SBVA` and running `make`.

You are now ready go. As an example, you could run
`python run_experiment 6 10 40 5 30 BT random` to generate 30 random
satisfiable and 30 random unsatisfiable 6-SAT instances in 10, 15, ..., 35
variables, solve them with the backtracking algorithm, and computing the
T-depth and T-count of a quantum algorithm for these instances. The data will
be saved to `data/BT-6-sat-random-10-40-5-30.csv` and can be plotted by running
`python plot_queries_over_n data/BT-6-sat-random-10-40-5-30.csv`. To compare
this with the quantum algorithm on other SAT instances or even with the
classical time complexity, you can call `plot_queries_over_n` with multiple .csv
files.
